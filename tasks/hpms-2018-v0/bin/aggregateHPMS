#!/usr/bin/env node

/* eslint no-console:0, no-plusplus: 0 */

const { join } = require('path');

const csv = require('fast-csv');

const csvtojson = require('csvtojson/v2');

const options = {
  objectMode: true,
  headers: true,
  ignoreEmpty: true,
  discardUnmappedColumns: true,
  trim: true
};

const precisionRound = (number, precision) => {
  let n = Number.isNaN(number) ? 1 : number;
  n = n === Infinity ? 10 : n;

  const factor = 10 ** precision;
  return Math.round(n * factor) / factor;
};

let Year_Record;

const dataByTmc = {};

const stateCodes2Tmcs = {};
const uaCodes2tmcs = {};

const collectInputData = data => {
  const { Travel_Time_Code, State_Code, Urban_Code } = data;

  dataByTmc[Travel_Time_Code] = data;

  if (State_Code) {
    stateCodes2Tmcs[State_Code] = stateCodes2Tmcs[State_Code] || [];
    stateCodes2Tmcs[State_Code].push(Travel_Time_Code);
  }

  if (Urban_Code) {
    uaCodes2tmcs[Urban_Code] = uaCodes2tmcs[Urban_Code] || [];
    uaCodes2tmcs[Urban_Code].push(Travel_Time_Code);
  }
};

const getTmc2Geos = () => {
  const years = new Set(
    Object.values(dataByTmc).map(({ Year_Record: yr }) => yr)
  );

  if (years.size > 1) {
    console.error('ERROR: Input data from multiple years.');
    process.exit(1);
  }

  [Year_Record] = [...years];

  // NOTE: Returns a promise
  return csvtojson().fromFile(
    join(__dirname, `./lib/tmc2geos_${Year_Record}.csv`)
  );
};

const getGeoLevelAttrs = () =>
  csvtojson().fromFile(join(__dirname, './lib/geoLevelAttrs.csv'));

const partitionTmcsByFSystem = tmcs => {
  const interstateTmcs = [];
  const noninterstateTmcs = [];

  for (let i = 0; i < tmcs.length; ++i) {
    const tmc = tmcs[i];
    const d = dataByTmc[tmc];

    if (d) {
      if (+dataByTmc[tmc].F_System === 1) {
        interstateTmcs.push(tmc);
      } else {
        noninterstateTmcs.push(tmc);
      }
    }
  }

  return { interstateTmcs, noninterstateTmcs };
};

const computeLOTTR = tmcs => {
  let passingWeight = 0;
  let totalWeights = 0;

  for (let i = 0; i < tmcs.length; i += 1) {
    const tmc = tmcs[i];
    const {
      DIR_AADT,
      Segment_Length,
      LOTTR_AMP,
      LOTTR_MIDD,
      LOTTR_PMP,
      LOTTR_WE,
      OCC_FAC
    } = dataByTmc[tmc];

    const tmcLOTTRWeight = DIR_AADT * Segment_Length * OCC_FAC;

    if (Math.max(LOTTR_AMP, LOTTR_MIDD, LOTTR_PMP, LOTTR_WE) < 1.5) {
      passingWeight += tmcLOTTRWeight;
    }

    totalWeights += tmcLOTTRWeight;
  }

  return passingWeight / totalWeights;
};

const computeTTTR = tmcs => {
  let totalWeights = 0;
  let totalLengths = 0;

  for (let i = 0; i < tmcs.length; i += 1) {
    const tmc = tmcs[i];
    const {
      Segment_Length,
      TTTR_AMP,
      TTTR_MIDD,
      TTTR_PMP,
      TTTR_WE,
      TTTR_OVN
    } = dataByTmc[tmc];

    const tmcLength = precisionRound(Segment_Length, 3);

    const tmcWeight =
      tmcLength * Math.max(TTTR_AMP, TTTR_MIDD, TTTR_PMP, TTTR_WE, TTTR_OVN, 1);

    totalWeights += tmcWeight;
    totalLengths += +tmcLength;
  }

  return totalWeights / totalLengths;
};

const computePHED = tmcs => {
  let phed = 0;

  for (let i = 0; i < tmcs.length; i += 1) {
    const tmc = tmcs[i];
    const { PHED } = dataByTmc[tmc];

    phed += +PHED;
  }

  return phed;
};

const outputAggregationsForGeo = ({
  Geography_Level,
  Geography_Code,
  Geography_Name,
  tmcs,
  statesStr
}) => {
  const { interstateTmcs, noninterstateTmcs } = partitionTmcsByFSystem(tmcs);

  const Interstate_LOTTR = precisionRound(computeLOTTR(interstateTmcs), 3);
  const Noninterstate_LOTTR = precisionRound(
    computeLOTTR(noninterstateTmcs),
    3
  );

  const Interstate_TTTR = precisionRound(computeTTTR(interstateTmcs), 3);
  const Noninterstate_TTTR = precisionRound(computeTTTR(noninterstateTmcs), 3);

  const Interstate_PHED = precisionRound(computePHED(interstateTmcs), 3);
  const Noninterstate_PHED = precisionRound(computePHED(noninterstateTmcs), 3);

  console.log(
    [
      Year_Record,
      statesStr,

      Geography_Level,
      Geography_Code,
      `"${Geography_Name}"`,

      Interstate_LOTTR,
      Noninterstate_LOTTR,

      Interstate_TTTR,
      Noninterstate_TTTR,

      Interstate_PHED,
      Noninterstate_PHED
    ].join()
  );
};

const getGeos2Tmcs = tmc2geos => {
  const mpos2Tmcs = {};
  const counties2Tmcs = {};

  for (let i = 0; i < tmc2geos.length; ++i) {
    const { Travel_Time_Code, MPO_Code, County_Code } = tmc2geos[i];

    if (dataByTmc[Travel_Time_Code]) {
      if (MPO_Code) {
        mpos2Tmcs[MPO_Code] = mpos2Tmcs[MPO_Code] || [];
        mpos2Tmcs[MPO_Code].push(Travel_Time_Code);
      }

      if (County_Code) {
        counties2Tmcs[County_Code] = counties2Tmcs[County_Code] || [];
        counties2Tmcs[County_Code].push(Travel_Time_Code);
      }
    }
  }

  return { mpos2Tmcs, counties2Tmcs };
};

const makeGeoAttrsFinder = (Geography_Level, Geography_Code) => ({
  geolevel,
  geocode
}) => geolevel === Geography_Level && +geocode === +Geography_Code;

const outputAggregationsForGeoLevel = ({
  Geography_Level,
  geo2tmcs,
  geoLevelAttrs
}) => {
  const geoCodes = Object.keys(geo2tmcs).sort();

  for (let i = 0; i < geoCodes.length; i += 1) {
    const Geography_Code = geoCodes[i];
    const tmcs = geo2tmcs[Geography_Code];

    const finder = makeGeoAttrsFinder(Geography_Level, Geography_Code);

    const geoAttrs = geoLevelAttrs.filter(finder);

    const [{ geoname: Geography_Name = null } = {}] = geoAttrs;

    if (geoAttrs.length > 1) {
      const states = geoAttrs.map(({ state }) => state).sort();

      const geoTmcsByState = states.reduce((acc, state) => {
        const { geocode: stateCode = null } =
          geoLevelAttrs.find(
            ({ geolevel, geoname }) => geolevel === 'STATE' && geoname === state
          ) || {};

        const tmcsInState = new Set(stateCodes2Tmcs[stateCode]);

        const geoStateTmcsIntersection = tmcs.filter(tmc =>
          tmcsInState.has(tmc)
        );

        if (geoStateTmcsIntersection.length) {
          acc[state] = geoStateTmcsIntersection;
        }

        return acc;
      }, {});

      Object.keys(geoTmcsByState).forEach(state =>
        outputAggregationsForGeo({
          Geography_Level,
          Geography_Code,
          Geography_Name,
          tmcs: geoTmcsByState[state],
          statesStr: state
        })
      );

      outputAggregationsForGeo({
        Geography_Level,
        Geography_Code,
        Geography_Name,
        tmcs,
        statesStr: states.join('_')
      });
    } else {
      const [{ state: statesStr = '' } = {}] = geoAttrs;

      outputAggregationsForGeo({
        Geography_Level,
        Geography_Code,
        Geography_Name,
        tmcs,
        statesStr
      });
    }
  }
};

const computeAggregations = async () => {
  const tmc2geos = await getTmc2Geos();
  const geoLevelAttrs = await getGeoLevelAttrs();

  const { mpos2Tmcs, counties2Tmcs } = getGeos2Tmcs(tmc2geos);

  console.log(
    [
      'Year_Record',
      'States',
      'Geography_Level',
      'Geography_Code',
      'Geography_Name',
      'Interstate_LOTTR',
      'Noninterstate_LOTTR',
      'Interstate_TTTR',
      'Noninterstate_TTTR',
      'Interstate_PHED',
      'Noninterstate_PHED'
    ].join()
  );

  outputAggregationsForGeoLevel({
    Geography_Level: 'STATE',
    geo2tmcs: stateCodes2Tmcs,
    geoLevelAttrs
  });

  outputAggregationsForGeoLevel({
    Geography_Level: 'COUNTY',
    geo2tmcs: counties2Tmcs,
    geoLevelAttrs
  });

  outputAggregationsForGeoLevel({
    Geography_Level: 'UA',
    geo2tmcs: uaCodes2tmcs,
    geoLevelAttrs
  });

  outputAggregationsForGeoLevel({
    Geography_Level: 'MPO',
    geo2tmcs: mpos2Tmcs,
    geoLevelAttrs
  });
};

const csvStream = csv(options)
  .on('data', collectInputData)
  .on('end', computeAggregations);

process.stdin.pipe(csvStream);
